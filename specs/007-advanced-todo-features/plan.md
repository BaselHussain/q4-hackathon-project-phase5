# Implementation Plan: Advanced Todo Features

**Branch**: `007-advanced-todo-features` | **Date**: 2026-02-09 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/007-advanced-todo-features/spec.md`

## Summary

Add advanced task management features (priority levels, due dates, tags, search/filter/sort, recurring tasks) to the existing Phase 3 Todo AI Chatbot. This extends the Task SQLModel with four new fields, updates three API endpoints, modifies five MCP tools, updates the agent instructions, and updates the Next.js frontend task management UI to support all new fields with priority filtering. All changes are backward-compatible with existing data. No Kafka/Dapr integration (deferred to Spec 8).

## Technical Context

**Language/Version**: Python 3.11+
**Primary Dependencies**: FastAPI 0.109+, SQLModel 0.0.14+, SQLAlchemy (async), Pydantic 2.5+, asyncpg 0.29+
**Storage**: Neon Serverless PostgreSQL (existing, schema migration via raw SQL)
**Testing**: Manual testing via Postman/curl + chatbot E2E (no pytest framework in repo currently)
**Target Platform**: Linux server (Docker), local dev on Windows
**Project Type**: Web application (backend/ + frontend/ at repo root)
**Constraints**: Backward compatibility with existing tasks, no breaking changes to auth flow

## Constitution Check

| Principle | Status | Notes |
|-----------|--------|-------|
| I. Educational Clarity | PASS | Plan documents exact file changes and commands |
| II. Engineering Accuracy | PASS | Production-grade patterns; enum + ARRAY types; parameterized queries |
| III. Practical Applicability | PASS | Works with existing local dev setup (uvicorn + MCP server) |
| IV. Spec-Driven Development | PASS | Follows approved spec.md with 58 FRs; implementation via Claude Code only |
| V. Ethical Responsibility | PASS | JWT auth preserved; user isolation enforced on all new query params |
| VI. Reproducibility | PASS | All changes documented; DB migration script provided |
| VII. Zero Broken State | PASS | Migration adds nullable columns with defaults; no breaking changes |

## Project Structure

### Documentation (this feature)

```text
specs/007-advanced-todo-features/
├── spec.md              # Approved specification
├── plan.md              # This file
├── data-model.md        # Data model changes (below)
├── contracts/           # API contract changes (below)
│   └── api-changes.md
├── checklists/
│   └── requirements.md  # Quality checklist
└── tasks.md             # Generated by /sp.tasks
```

### Source Code Changes (files to modify/create)

```text
backend/
├── src/models/task.py           # MODIFY: Add Priority, Recurrence enums + 4 new Task fields
├── schemas.py                   # MODIFY: Update TaskCreate, TaskUpdate, TaskResponse schemas
├── routers/tasks.py             # MODIFY: Add query params to GET, new fields to POST/PUT
├── tools/tasks.py               # MODIFY: Update add_task, update_task, list_tasks MCP tools
├── src/agents/todo_agent.py     # MODIFY: Update agent instructions for new capabilities
├── models.py                    # NO CHANGE: Re-exports from src.models (auto-picks up changes)
├── database.py                  # NO CHANGE
├── main.py                      # NO CHANGE
└── migrate_advanced_features.py # CREATE: One-time migration script for new columns
```

**Structure Decision**: Modify existing files in-place. No new service layer needed — business logic stays in routers and MCP tools as per existing patterns. The codebase uses thin routers with inline SQLAlchemy queries, and MCP tools with inline DB logic. We follow this existing pattern.

---

## Decision Table

| # | Decision | Options Considered | Choice | Rationale |
|---|----------|--------------------|--------|-----------|
| D1 | Priority storage | (A) String column (B) PostgreSQL ENUM type (C) Python enum + String column | **C** | Python `enum.Enum` for type safety in code; stored as VARCHAR in DB. Matches existing `TaskStatus` pattern in `task.py:15-17`. Avoids Neon PG ENUM migration complexity. |
| D2 | Tags storage | (A) Comma-separated string (B) PostgreSQL ARRAY (C) JSON column (D) Separate tags table | **B** | PostgreSQL ARRAY (`ARRAY(String)`) for efficient `@>` (contains) and `ANY()` queries. Neon PG supports arrays natively. Avoids join overhead of separate table. Simple for the current scale. |
| D3 | Recurrence storage | (A) String enum only (B) JSON with pattern + metadata (C) Python enum + String column | **C** | Python `enum.Enum` + VARCHAR, same pattern as Priority. Simple enum covers required patterns (none/daily/weekly/monthly/yearly). Advanced patterns (Spec 8) can extend later without schema change by switching to JSON. |
| D4 | Due date storage | (A) Date only (B) DateTime with timezone (C) DateTime without timezone | **B** | `DateTime(timezone=True)` matches existing `created_at`/`updated_at` pattern. Timezone-aware enables correct overdue detection and Spec 8 reminder scheduling. |
| D5 | Search implementation | (A) PostgreSQL ILIKE (B) Full-text search (tsvector) (C) Application-level filtering | **A** | `ILIKE '%keyword%'` is simple, adequate for current scale (<10K tasks per user). Full-text search is over-engineered for this phase. Can upgrade in Spec 8 if needed. |
| D6 | Filter/sort approach | (A) Raw SQL strings (B) SQLAlchemy dynamic query builder (C) Stored procedures | **B** | Dynamic `select().where().order_by()` chain. Type-safe, injection-proof, matches existing codebase pattern in `routers/tasks.py:55-58` and `tools/tasks.py:149-157`. |
| D7 | DB migration approach | (A) Alembic auto-generate (B) Raw SQL migration script (C) SQLModel create_all | **B** | Raw SQL `ALTER TABLE` script. No Alembic in repo currently. Adding Alembic for 4 columns is over-engineering. Script is idempotent with `IF NOT EXISTS` checks. |
| D8 | Agent date parsing | (A) Custom date parser in backend (B) Let LLM parse dates into ISO format (C) dateutil library | **B** | The OpenAI agent (gpt-4o-mini) already handles natural language → structured data. Agent instructions tell it to convert "by Friday" into ISO 8601 datetime before calling MCP tools. Zero backend code needed. |

---

## Data Model Changes

### Enhanced Task Model (`backend/src/models/task.py`)

**New enums** (add after `TaskStatus`):

```python
class TaskPriority(str, enum.Enum):
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"

class TaskRecurrence(str, enum.Enum):
    NONE = "none"
    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"
    YEARLY = "yearly"
```

**New fields on Task model** (add after `status` field):

| Field | Type | SQLAlchemy Column | Default | Nullable | Index | FR |
|-------|------|-------------------|---------|----------|-------|-----|
| `priority` | `TaskPriority` | `String(10), nullable=False` | `TaskPriority.MEDIUM` | No | Yes | FR-041 |
| `due_date` | `Optional[datetime]` | `DateTime(timezone=True), nullable=True` | `None` | Yes | Yes | FR-040 |
| `tags` | `Optional[list[str]]` | `ARRAY(String(50)), nullable=True` | `None` | Yes | No (GIN index later if needed) | FR-042 |
| `recurrence` | `TaskRecurrence` | `String(10), nullable=False` | `TaskRecurrence.NONE` | No | No | FR-043 |

**Imports to add**: `from sqlalchemy import ARRAY` (for tags column)

### Database Migration Script (`backend/migrate_advanced_features.py`)

Idempotent SQL migration — safe to run multiple times:

```sql
-- Add priority column (default 'medium' for existing rows)
ALTER TABLE tasks ADD COLUMN IF NOT EXISTS priority VARCHAR(10) NOT NULL DEFAULT 'medium';

-- Add due_date column (nullable)
ALTER TABLE tasks ADD COLUMN IF NOT EXISTS due_date TIMESTAMPTZ;

-- Add tags column (PostgreSQL array of strings, nullable)
ALTER TABLE tasks ADD COLUMN IF NOT EXISTS tags TEXT[];

-- Add recurrence column (default 'none' for existing rows)
ALTER TABLE tasks ADD COLUMN IF NOT EXISTS recurrence VARCHAR(10) NOT NULL DEFAULT 'none';

-- Add indexes for common query patterns
CREATE INDEX IF NOT EXISTS ix_tasks_priority ON tasks (priority);
CREATE INDEX IF NOT EXISTS ix_tasks_due_date ON tasks (due_date);
CREATE INDEX IF NOT EXISTS ix_tasks_user_priority ON tasks (user_id, priority);
CREATE INDEX IF NOT EXISTS ix_tasks_user_due_date ON tasks (user_id, due_date);
```

**Backward compatibility**: All existing tasks get `priority='medium'` and `recurrence='none'` via defaults. `due_date` and `tags` are nullable, so existing rows remain valid with NULL.

---

## API Contract Changes

### 1. POST `/api/{user_id}/tasks` — Create Task (FR-044)

**Current schema** (`TaskCreate`):
```json
{ "title": "string", "description": "string|null" }
```

**Updated schema** (`TaskCreate`):
```json
{
  "title": "string",
  "description": "string|null",
  "due_date": "datetime|null",
  "priority": "high|medium|low",  // default: "medium"
  "tags": ["string"]|null,
  "recurrence": "none|daily|weekly|monthly|yearly"  // default: "none"
}
```

**All new fields are optional** with defaults. Existing clients sending `{ "title": "..." }` continue to work.

### 2. GET `/api/{user_id}/tasks` — List Tasks (FR-045)

**Current**: No query params (returns all tasks, newest first)

**Updated query params**:

| Param | Type | Values | Default | Description | FR |
|-------|------|--------|---------|-------------|-----|
| `status` | string | `all`, `pending`, `completed` | `all` | Filter by task status | FR-022 |
| `priority` | string | `high`, `medium`, `low` | (none) | Filter by priority | FR-023 |
| `tags` | string | comma-separated | (none) | Filter by tags (AND logic: task must have ALL specified tags) | FR-024 |
| `due_before` | datetime | ISO 8601 | (none) | Tasks due before this date | FR-025 |
| `due_after` | datetime | ISO 8601 | (none) | Tasks due after this date | FR-025 |
| `overdue` | bool | `true`, `false` | `false` | Show only overdue tasks (due_date < now AND status=pending) | FR-027 |
| `search` | string | keyword | (none) | Case-insensitive search in title and description | FR-018 |
| `sort` | string | `priority`, `due_date`, `created_at`, `status` | `created_at` | Sort field | FR-028-031 |
| `order` | string | `asc`, `desc` | `desc` | Sort direction | FR-028-031 |

**Combining filters**: All filters use AND logic (FR-026). Example:
```
GET /api/{user_id}/tasks?status=pending&priority=high&tags=work&sort=due_date&order=asc
```

### 3. PUT `/api/{user_id}/tasks/{task_id}` — Update Task (FR-046)

**Current schema** (`TaskUpdate`):
```json
{ "title": "string|null", "description": "string|null" }
```

**Updated schema** (`TaskUpdate`):
```json
{
  "title": "string|null",
  "description": "string|null",
  "due_date": "datetime|null",
  "priority": "high|medium|low|null",
  "tags": ["string"]|null,
  "recurrence": "none|daily|weekly|monthly|yearly|null"
}
```

**Behavior**: Only provided (non-null) fields are updated. To clear `due_date`, send `"due_date": null` explicitly. Existing `model_post_init` validation rule ("at least one field") now applies across all 6 fields.

### 4. TaskResponse — Updated Response Schema

```json
{
  "id": "uuid",
  "user_id": "uuid",
  "title": "string",
  "description": "string|null",
  "status": "pending|completed",
  "priority": "high|medium|low",
  "due_date": "datetime|null",
  "tags": ["string"]|null,
  "recurrence": "none|daily|weekly|monthly|yearly",
  "created_at": "datetime",
  "updated_at": "datetime"
}
```

---

## MCP Tool Changes

### `add_task` (FR-048)

**Current signature**: `add_task(user_id, title, description=None)`
**New signature**: `add_task(user_id, title, description=None, due_date=None, priority="medium", tags=None, recurrence="none")`

- `due_date`: ISO 8601 string or None. The LLM agent converts natural language dates before calling.
- `priority`: Validated against ["high", "medium", "low"]. Default "medium".
- `tags`: Comma-separated string or None. Parsed into list. E.g., "work,urgent" → ["work", "urgent"].
- `recurrence`: Validated against ["none", "daily", "weekly", "monthly", "yearly"]. Default "none".
- Update `serialize_task()` to include new fields in response.

### `update_task` (FR-049)

**Current signature**: `update_task(user_id, task_id, title=None, description=None)`
**New signature**: `update_task(user_id, task_id, title=None, description=None, due_date=None, priority=None, tags=None, recurrence=None)`

- Same validation as `add_task` for new fields.
- Only non-None fields are updated (existing pattern preserved).

### `list_tasks` (FR-050)

**Current signature**: `list_tasks(user_id, status="all")`
**New signature**: `list_tasks(user_id, status="all", priority=None, tags=None, search=None, sort="created_at", order="desc", overdue="false")`

- `priority`: Filter by priority level.
- `tags`: Comma-separated. Filter tasks containing ALL specified tags.
- `search`: Case-insensitive ILIKE search across title and description.
- `sort`: One of ["priority", "due_date", "created_at", "status"]. Default "created_at".
- `order`: "asc" or "desc". Default "desc".
- `overdue`: "true" to show only overdue tasks. Default "false".

### `serialize_task` helper update

Add new fields to the serialization output:
```python
def serialize_task(task: Task) -> dict:
    return {
        "task_id": str(task.id),
        "title": task.title,
        "description": task.description,
        "status": task.status.value,
        "priority": task.priority.value,
        "due_date": task.due_date.isoformat() if task.due_date else None,
        "tags": task.tags if task.tags else [],
        "recurrence": task.recurrence.value,
        "created_at": task.created_at.isoformat() if task.created_at else None,
        "updated_at": task.updated_at.isoformat() if task.updated_at else None,
    }
```

---

## Agent Instructions Update (`backend/src/agents/todo_agent.py`)

Update `AGENT_INSTRUCTIONS` to inform the LLM about new capabilities:

```
Your capabilities:
- Add new tasks with optional priority, due date, tags, and recurrence
- List tasks with filtering (status, priority, tags, overdue), sorting, and search
- Mark tasks as completed
- Delete tasks
- Update task titles, descriptions, priorities, due dates, tags, and recurrence

Guidelines for new features:
1. Priority: Extract priority from user input (e.g., "high priority", "urgent" = high, "low priority" = low). Default to medium.
2. Due dates: Convert natural language to ISO 8601 format (e.g., "by Friday" → "2026-02-14T23:59:00Z"). Pass as due_date parameter.
3. Tags: Extract hashtags or categories (e.g., "#work #urgent" → tags="work,urgent"). Pass as comma-separated string.
4. Recurrence: Detect patterns like "daily", "every week", "monthly" → recurrence="daily"/"weekly"/"monthly"/"yearly".
5. Search: When users say "find tasks about X" or "search for X", use the search parameter.
6. Filter: When users say "show high priority" or "show overdue", use filter parameters.
7. Sort: When users say "sort by priority" or "sort by due date", use sort parameter.
8. When listing tasks, include priority, due date, tags, and recurrence in the formatted output.
```

---

## Step-by-Step Integration Plan

### Phase 1: Data Model + Migration (Blocking)

1. **Update `backend/src/models/task.py`**:
   - Add `TaskPriority` enum (high, medium, low)
   - Add `TaskRecurrence` enum (none, daily, weekly, monthly, yearly)
   - Add `priority` field to Task (default=medium, not nullable)
   - Add `due_date` field to Task (nullable DateTime with timezone)
   - Add `tags` field to Task (nullable ARRAY of String)
   - Add `recurrence` field to Task (default=none, not nullable)
   - Add required imports: `from sqlalchemy import ARRAY`

2. **Create `backend/migrate_advanced_features.py`**:
   - Async script using existing `database.py` engine
   - Execute ALTER TABLE statements (idempotent with IF NOT EXISTS)
   - Create indexes on priority, due_date
   - Print confirmation of migration success

3. **Run migration**:
   ```bash
   cd backend && python migrate_advanced_features.py
   ```

### Phase 2: Schemas + Router (US1: Priorities & Due Dates)

4. **Update `backend/schemas.py`**:
   - Add `due_date`, `priority`, `tags`, `recurrence` to `TaskCreate` (all optional with defaults)
   - Add `due_date`, `priority`, `tags`, `recurrence` to `TaskUpdate` (all optional)
   - Update `model_post_init` to check all 6 fields
   - Add `due_date`, `priority`, `tags`, `recurrence` to `TaskResponse`
   - Import `TaskPriority`, `TaskRecurrence` from models for validation

5. **Update `backend/routers/tasks.py`**:
   - `create_task`: Pass new fields from `task_data` to `Task()` constructor
   - `update_task`: Handle new fields in update logic
   - `list_tasks`: Add query params (status, priority, tags, due_before, due_after, overdue, search, sort, order)
   - Build dynamic SQLAlchemy query based on provided params
   - Implement sort with secondary sort (priority → due_date → created_at)

### Phase 3: MCP Tools (US1 + US2: All Features via Chatbot)

6. **Update `backend/tools/tasks.py`**:
   - `serialize_task()`: Add priority, due_date, tags, recurrence to output
   - `add_task()`: Add new parameters, validate, pass to Task constructor
   - `update_task()`: Add new parameters, validate, update fields
   - `list_tasks()`: Add filter/sort/search params, build dynamic query
   - Add helper functions for tag parsing and priority/sort validation

7. **Update `backend/src/agents/todo_agent.py`**:
   - Expand `AGENT_INSTRUCTIONS` with new capability descriptions
   - Add guidelines for date parsing, tag extraction, priority detection
   - Add sort/filter/search usage instructions

### Phase 4: Validation & Polish (US3: Recurring Tasks + Edge Cases)

8. **Validation in schemas**:
   - Priority must be one of: high, medium, low
   - Recurrence must be one of: none, daily, weekly, monthly, yearly
   - Tags: max 10 tags per task, max 50 chars per tag
   - Due date: accept any valid datetime (including past dates for overdue)

9. **Edge case handling**:
   - Empty tags array → store as NULL
   - Search with no results → return empty list (chatbot shows friendly message)
   - Invalid sort field → return 422 with valid options
   - Multiple filters combined → AND logic in query

---

## Testing Strategy

### Manual API Testing (Postman/curl)

**Test 1: Create task with all new fields**
```bash
curl -X POST http://localhost:8000/api/{user_id}/tasks \
  -H "Authorization: Bearer {token}" \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Finish project proposal",
    "description": "Complete the Q4 proposal draft",
    "due_date": "2026-02-14T23:59:00Z",
    "priority": "high",
    "tags": ["work", "urgent"],
    "recurrence": "none"
  }'
# Expected: 201 Created with all fields in response
```

**Test 2: Create task with defaults (backward compatibility)**
```bash
curl -X POST http://localhost:8000/api/{user_id}/tasks \
  -H "Authorization: Bearer {token}" \
  -H "Content-Type: application/json" \
  -d '{"title": "Simple task"}'
# Expected: 201 Created with priority=medium, recurrence=none, due_date=null, tags=null
```

**Test 3: Filter by priority and status**
```bash
curl "http://localhost:8000/api/{user_id}/tasks?status=pending&priority=high" \
  -H "Authorization: Bearer {token}"
# Expected: Only pending + high priority tasks
```

**Test 4: Search by keyword**
```bash
curl "http://localhost:8000/api/{user_id}/tasks?search=proposal" \
  -H "Authorization: Bearer {token}"
# Expected: Tasks with "proposal" in title or description
```

**Test 5: Sort by due date ascending**
```bash
curl "http://localhost:8000/api/{user_id}/tasks?sort=due_date&order=asc" \
  -H "Authorization: Bearer {token}"
# Expected: Tasks ordered by due_date, earliest first (nulls last)
```

**Test 6: Filter overdue tasks**
```bash
curl "http://localhost:8000/api/{user_id}/tasks?overdue=true" \
  -H "Authorization: Bearer {token}"
# Expected: Only tasks with due_date < now AND status=pending
```

**Test 7: Filter by tags**
```bash
curl "http://localhost:8000/api/{user_id}/tasks?tags=work,urgent" \
  -H "Authorization: Bearer {token}"
# Expected: Tasks containing BOTH "work" AND "urgent" tags
```

**Test 8: Update task with new fields**
```bash
curl -X PUT http://localhost:8000/api/{user_id}/tasks/{task_id} \
  -H "Authorization: Bearer {token}" \
  -H "Content-Type: application/json" \
  -d '{
    "priority": "low",
    "due_date": "2026-03-01T12:00:00Z",
    "tags": ["personal"],
    "recurrence": "weekly"
  }'
# Expected: 200 OK with updated fields
```

**Test 9: Create recurring task**
```bash
curl -X POST http://localhost:8000/api/{user_id}/tasks \
  -H "Authorization: Bearer {token}" \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Team standup",
    "recurrence": "daily",
    "priority": "medium",
    "tags": ["work", "meeting"]
  }'
# Expected: 201 Created with recurrence=daily
```

**Test 10: Invalid priority → 422**
```bash
curl -X POST http://localhost:8000/api/{user_id}/tasks \
  -H "Authorization: Bearer {token}" \
  -H "Content-Type: application/json" \
  -d '{"title": "Test", "priority": "critical"}'
# Expected: 422 Unprocessable Entity
```

### Chatbot E2E Testing

```
User: "Add high priority task: Review PR by tomorrow #work #code-review"
→ Agent calls add_task with priority="high", due_date=<tomorrow ISO>, tags="work,code-review"

User: "Show my high priority tasks"
→ Agent calls list_tasks with priority="high"

User: "What's overdue?"
→ Agent calls list_tasks with overdue="true"

User: "Search for tasks about meeting"
→ Agent calls list_tasks with search="meeting"

User: "Sort my tasks by due date"
→ Agent calls list_tasks with sort="due_date", order="asc"

User: "Add daily task: Check emails"
→ Agent calls add_task with recurrence="daily"

User: "Change task priority to low"
→ Agent calls update_task with priority="low"
```

---

## Risk Mitigation

| # | Risk | Impact | Likelihood | Mitigation |
|---|------|--------|------------|------------|
| R1 | DB migration fails on Neon | Tasks table breaks | Low | Migration is idempotent (IF NOT EXISTS). Test on dev DB first. Rollback: DROP COLUMN IF EXISTS. |
| R2 | Existing tasks break after migration | 500 errors on list/get | Low | All new columns have defaults or are nullable. `TaskResponse` uses `from_attributes=True` which handles extra fields gracefully. |
| R3 | ARRAY type not supported on Neon PG | Tags feature fails | Very Low | Neon supports PostgreSQL ARRAY natively. Fallback: use JSON column with `JSONB` type. |
| R4 | Agent fails to parse dates correctly | Wrong due dates stored | Medium | Agent instructions explicitly say "convert to ISO 8601". LLM handles this well. If parsing fails, due_date is simply omitted (nullable). |
| R5 | Search performance degrades at scale | Slow GET responses | Low (current scale) | ILIKE is fine for <10K tasks/user. Add GIN index on title later if needed. Monitor query times. |
| R6 | MCP tool signature changes break agent | Agent can't call tools | Medium | MCP tools use keyword arguments with defaults. Existing calls (without new params) continue to work. Agent auto-discovers updated tool schemas. |

---

## Phase 8: Frontend UI Integration

**Purpose**: Update the Next.js frontend task management UI to support all new advanced task fields (priority, due date, tags, recurrence) and add priority filtering.

### Files to Modify

```text
frontend/src/
├── lib/api.ts              # MODIFY: Update Task interface and API transform functions to include new fields
├── hooks/useTasks.ts       # MODIFY: Update TaskData interface used by task forms
├── components/tasks/
│   ├── TaskForm.tsx         # MODIFY: Add priority, due date, tags, recurrence form fields
│   ├── TaskModal.tsx        # MODIFY: Update type signatures for new TaskData shape
│   ├── TaskCard.tsx         # MODIFY: Display priority badge, due date, tags, recurrence indicator
│   ├── TaskFilter.tsx       # MODIFY: Add priority filter dropdown (All/High/Medium/Low)
│   └── TaskList.tsx         # MODIFY: Wire priority filter state into API query params
```

### Approach

- **Reuse existing UI components**: Badge, Select, Input, Label from shadcn/ui are already installed. No new dependencies needed.
- **Priority badge**: Use Badge component with variant colors — high=red (`destructive`), medium=amber (`default`/custom), low=blue (`secondary`).
- **Due date field**: Use native HTML date input or existing Input component with `type="datetime-local"`.
- **Tags input**: Use a text Input where users type comma-separated tags. Display as Badge components on task cards.
- **Recurrence select**: Use Select component with options: None, Daily, Weekly, Monthly, Yearly.
- **Overdue indicator**: Compare due_date to current date client-side. If past due and status is pending, render due date text in red.
- **Priority filter**: Add a Select dropdown to TaskFilter. Pass selected priority as query parameter to the list tasks API call.

### Key Decisions

| # | Decision | Choice | Rationale |
|---|----------|--------|-----------|
| D9 | Tags input method | Comma-separated text input | Simple, matches backend API format. No need for a complex tag picker library. |
| D10 | Date input type | Native `datetime-local` input | Works across modern browsers, no extra dependency. Sufficient for date+time entry. |
| D11 | Priority filter location | Inside existing TaskFilter component | Consistent with existing status filter pattern. Single source of filter state. |

---

## Complexity Tracking

No constitution violations. All changes follow existing patterns:
- Enums match `TaskStatus` pattern
- Fields match existing Column/Field style
- Routers follow existing query pattern
- MCP tools follow existing validation pattern
